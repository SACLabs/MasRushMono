"""
## The MAS(Multi-agent System) will do:
# @WangXuhongCN
- Step1: receive the packed data from ENV
- Step2: unpack the data
- Step3: It first interpretate the readme.md and understand the requirements of the task (through some LLM tools), turn it into a task list (in todo.txt style)
- Step4: The task list will then be transfer into a graph state, in which each node is a specific agent that has a specific task to do. A entry node is used to send the task list to other agents, and a exit node is used to collect the results from all agent.
- Step5: The relations of nodes in state transition graph created in Step4 will then be optimized by algorithms included in **MAS**
- Step6: The optimized graph will then be run by the MAS, and the results will be collected and sent back to ENV, including:
  - a. task_id
  - b. the generated code
  - c. the generated tests, these tests is generated by MAS to gain more understand of the code it generated
  - d. the generated run.sh
  - e. the changelog of task list
  - f. the graph of state transition
"""

from masr.models.interface import Demand, EnvOutput, MASOutput
from masr.models.task import TaskHistory
from tests.test_base import (
    task_id,
    source_code,
    task_desc,
    gml,
    report,
    nxgraph,
    demand,
)
from unittest import mock

mock_task_id = task_id
mock_demand = demand
mock_history = TaskHistory(history=[task_desc])
mock_report = report
mock_src = source_code
mock_graph = nxgraph
mock_gml = gml

mas_input = {
    "task_id": task_id,
    "content": {"demand": mock_demand, "report": mock_report, "src": mock_src},
}

mas_output = {
    "task_id": task_id,
    "content": {
        "result": mock_src,
        "history": mock_history,
        "graph": mock_gml,
    },
}


# TODO 实现pipeline循环
def test_mas_pipeline():
    mock_pipeline = mock.Mock()
    mock_pipeline.return_value = mas_output
    with mock.patch("masr.mas.main.pipeline", mock_pipeline):
        output = mock_pipeline(mas_input)
        assert mas_output == output


def test_interpret_demand():
    # interpret_readme 函数,读取demand，应返回TaskHistory对象
    expected_result = mock_history
    with mock.patch(
        "masr.mas.main.interpret_demand", return_value=expected_result
    ) as mock_run:
        output_result = mock_run(mock_demand)
        assert expected_result == output_result


def test_create_graph():
    # creating a graph state from the task list
    expected_result = mock_graph
    with mock.patch(
        "masr.mas.main.create_graph", return_value=expected_result
    ) as mock_run:
        output_result = mock_run(mock_history)
        assert expected_result == output_result


def test_optimize_graph():
    # graph optimization
    expected_result = mock_graph
    with mock.patch(
        "masr.mas.main.optimize_graph", return_value=expected_result
    ) as mock_run:
        output_result = mock_run(mock_graph)
        assert expected_result == output_result


def test_run_graph():
    # Simulate running the optimized graph and collecting results
    expected_result = MASOutput(
        task_id=mock_task_id,
        result=mock_src,
        graph=mock_gml,
        history=mock_history,
    )
    with mock.patch(
        "masr.mas.main.run_graph", return_value=expected_result
    ) as mock_run:
        output_result = mock_run(mock_graph)
        assert expected_result == output_result


def test_mas_run():
    pass
